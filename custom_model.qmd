---
title: "Custom SEM"
format: pdf
editor: visual
---

# Setup

```{r}
#| message: false
#| warning: false

# install.packages('TMB', type = 'source', lib = .libPaths()[2]) 
library('RTMB', lib.loc = .libPaths()[2])
library('tidyverse')
library(CatDyn)
library(tmbstan)
library(shinystan)

load("data/df_effort_m_mbw_otb.Rdata")

precip = c(-16.67,
           115.33, 245.93, 193.93, -229.47,-76.47,
           250.33, 177.73, 115.63, 90.13, -299.57,
           -338.37,97.18, -317.67, -198.74,-14.07,
           221.67, -90.97, -205.97, 98.03, 256.73,
           -241.87, 150.13, -300.17, 98.43, -85.87,
           -94.67,-156.87,-43.87,-106.37) + 
  735.8 + 105.7
anos = 1994:2023

``` 

# Data

## Catch per Unit of Effort $CPUE_t$

Catch is obtained via reported landings. It is converted to number of individuals via a mean body weight model (not described here). Catches in MAGD are typically modeled in numbers.

Since we are dealing with a polyvalent fishery that employs a wide range of fishing gears and operates in vessels that are small enough to be exempt from keeping logbooks, effort data can be estimated at best by attempting to count fishing days in each month.

```{r}
df_effort %>% 
  ggplot() + 
  geom_line(aes(x = 1:348,
                y = catch_otb/effort_otb)) + 
  theme_bw() + 
  labs(title = 'nominal CPUE (kg/day)')
```

## Yearly precipitation data for the region, to be incorporated at a later date

```{r}
  ggplot() + 
  geom_line(aes(x = anos,
                y = precip)) + 
  theme_bw() + 
  labs(title = 'Yearly precipitation')
```

# Defining the model

We have a biomass time series that is unobservable and therefore, latent. We can use our measurements for Capture and Effort at month $t$ ($C_t$ and $E_t$). Our challenge will come from incorporating the precipitation from the previous year, $P_{t-1}$   

## Basic model

In this model we estimate $phi$ and $C_{0}$ (which the catch at $t = 0$ and not actually part of the catch series, hence why the need for estimation). Parameters are modeled without explicit prior distributions, meaning a flat uniform distribution will be assumed by **RTMB**. 

$$
C_{t+1} = \phi \cdot C_t  + \epsilon_t
$$

```{r}
#| eval: false
dat = list()

# DO NOT USE DATA FRAMES!
# P_{t-1} = lagP

dat$y = as.vector(df_effort$catch_otb)  # catches

# initialize parameter list with initial estimates
par = list()
par$logSdY = 1 # We must ensure positive numbers, so we work with logs
par$phi = 1
par$y0 = mean(dat$y)

# if we treat phi and alpha as priors, then we must specify the distribution
# therefore we would need to add dispersion paramaters
# If we fail to do so, a flat uniform distribution is defaulted to 
# par$logsdphi = 0
# First pass: Linear model, lol

# initialize joint negative loglikelihood function
jnll = function(par){
  getAll(par, dat) # invoke all the parameters and data
  
  # gather and cleanup pars
  y = OBS(y)
  sdY = exp(logSdY)
  # sdalpha = exp(logsdalpha) 
  # sdphi = exp(logsdphi) # will be used by dnorm below
  
  # assemble model    
  jnll = 0 # init jnll
  ## from alpha
  # jnll = jnll - dnorm(alpha, 1, log = TRUE)
  ## from phi
  # jnll = jnll - dnorm(phi, 1, log = TRUE)
  ## from y0
  # jnll = jnll - dnorm(y0, 1, log = TRUE)
  
  ## From the observation process
  predictions = c()
  for(i in 1:length(y)){
    if(i == 1) {predY = phi*y0}
    else{predY = phi*y[i-1]}
    jnll = jnll - dnorm(y[i], predY, sdY, log=TRUE)
    predictions[i] = predY
  }
  REPORT(predictions)
  jnll
}

# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj = MakeADFun(jnll, par)
fit = nlminb(obj$par, obj$fn, obj$gr)

sdr = sdreport(obj)
pl = as.list(sdr,"Est")
plsd = as.list(sdr,"Std")
```

## Second model: Added precipitation

In this version, we added rainfall $P_t$ from the previous year to the model. The series is actually lagged, so any given $P_{1995}$ will actually refer to the year of 1994, *eg*. This was done for ease of integration. 

$$
C_{t+1} = \phi \cdot C_t + \alpha\cdot P_t + \epsilon_t
$$

```{r}
#| eval: false
dat = list()

# DO NOT USE DATA FRAMES!
# P_{t-1} = lagP

dat$y = as.vector(df_effort$catch_otb)  # catches
dat$x = as.vector(rep(precip[1:29], each = 12)) # rainfall

# initialize parameter list with initial estimates
par = list()
par$logSdY = 1 # We must ensure positive numbers, so we work with logs
par$phi = 1
par$alpha = 1
par$y0 = mean(dat$y)

# if we treat phi and alpha as priors, then we must specify the distribution
# therefore we would need to add dispersion parameters
# If we fail to do so, a flat uniform distribution is defaulted to 
# par$logsdphi = 0
# par$logsdalpha = 0
# First pass: Linear model, lol

# initialize joint negative loglikelihood function
jnll = function(par){
  getAll(par, dat) # invoke all the parameters and data
  
  # gather and cleanup pars
  y = OBS(y)
  sdY = exp(logSdY)
  # sdalpha = exp(logsdalpha) 
  # sdphi = exp(logsdphi) # will be used by dnorm below
  
  # assemble model    
  jnll = 0 # init jnll
  ## from alpha
  # jnll = jnll - dnorm(alpha, 1, log = TRUE)
  ## from phi
  # jnll = jnll - dnorm(phi, 1, log = TRUE)
  ## from y0
  # jnll = jnll - dnorm(y0, 1, log = TRUE)
  
  ## From the observation process
  predictions = c()
  for(i in 1:length(x)){
    if(i == 1) {predY = phi*y0 + alpha*x[i]}
    else{predY = phi*y[i-1]+ alpha*x[i]}
    jnll = jnll - dnorm(y[i], predY, sdY, log=TRUE)
    predictions[i] = predY
  }
  REPORT(predictions)
  jnll
}

# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj2 = MakeADFun(jnll, par)
fit2 = nlminb(obj2$par, obj2$fn, obj2$gr)

sdr2 = sdreport(obj2)
pl2 = as.list(sdr2,"Est")
plsd2 = as.list(sdr2,"Std")
```

## Third model: Now with hard priors

We account for uncertainty in $\phi$, $\alpha$ and $\sigma_{t}$, so we include distribution parameters for these quantities to be estimated.

```{r}
#| eval: false
dat = list()

# DO NOT USE DATA FRAMES!
# P_{t-1} = lagP

dat$y = as.vector(df_effort$catch_otb)  # catches
dat$x = as.vector(rep(precip[1:29], each = 12)) # rainfall

# initialize parameter list with initial estimates
par = list()
par$logSdY = 1 # We must ensure positive numbers, so we work with logs
par$phi = 1
par$alpha = 1
par$y0 = mean(dat$y)

# if we treat phi and alpha as priors, then we must specify the distribution
# therefore we would need to add dispersion parameters
# If we fail to do so, a flat uniform distribution is defaulted to 
par$logsdphi = 0
par$logsdalpha = 0
par$logsdy0 = 0
# First pass: Linear model, lol

# initialize joint negative loglikelihood function
jnll = function(par){
  getAll(par, dat) # invoke all the parameters and data
  
  # gather and cleanup pars
  y = OBS(y)
  sdY = exp(logSdY)
  sdalpha = exp(logsdalpha)
  sdphi = exp(logsdphi) # will be used by dnorm below
  sdy0 = exp(logsdy0)
  
  # assemble model    
  jnll = 0 # init jnll
  ## from alpha
  jnll = jnll - dnorm(alpha, sdalpha, log = TRUE)
  ## from phi
  jnll = jnll - dnorm(phi, sdphi, log = TRUE)
  ## from y0
  jnll = jnll - dnorm(y0, sdy0, log = TRUE)
  
  ## From the observation process
  predictions = c()
  for(i in 1:length(x)){
    if(i == 1) {predY = phi*y0 + alpha*x[i]}
    else{predY = phi*y[i-1]+ alpha*x[i]}
    jnll = jnll - dnorm(y[i], predY, sdY, log=TRUE)
    predictions[i] = predY
  }
  REPORT(predictions)
  jnll
}

# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj3 = MakeADFun(jnll, par)
fit3 = nlminb(obj3$par, obj3$fn, obj3$gr)

sdr3 = sdreport(obj3)
pl3 = as.list(sdr3,"Est")
plsd3 = as.list(sdr3,"Std")

sdr3
```

#














```{r}
#| eval: false
#| # library(tmbstan)
fit2 = tmbstan(obj,chains=1,iter=1000)
# library(shinystan)
launch_shinystan(fit2)
```

## Prediction plots (generated from the deterministic part of the jnll function)

```{r}
  df_effort %>% 
  ggplot() + 
  geom_line(aes(y = dat$y,
                x = 1:348)) +
    geom_line(aes(x = 1:348,
                y = obj2$report()$predictions),
            col = 'red') +
  geom_line(aes(x = 1:348,
                y = obj$report()$predictions),
            col = 'green') +
  theme_bw() + 
  labs(title = 'With (green) and without (red) precipitation')
```

## Prediction plots from generated data via the parameters

```{r}
yhat = c()
for(i in 1:length(dat$y)){
  if(i == 1){yhat[i] = par$y0}
  else{yhat[i] = yhat[i-1]*sdr2$par.fixed[['phi']] +
    sdr2$par.fixed[['alpha']]*dat$x[i] +
    rnorm(1,0,exp(sdr2$par.fixed[['logSdY']]))}
}

yhat_no_p = c()
for(i in 1:length(dat$y)){
  if(i == 1){yhat_no_p[i] = par$y0}
  else{yhat_no_p[i] = yhat_no_p[i-1]*sdr2$par.fixed[['phi']]+
    rnorm(1,0,exp(sdr2$par.fixed[['logSdY']]))}
}

df_effort %>% 
  ggplot() + 
  geom_line(aes(y = dat$y,
                x = 1:348)) +
  geom_line(aes(y = yhat,
                x = 1:348),
            col = 'green') +
  geom_line(aes(x = 1:348,
                y = yhat_no_p),
            col = 'red') +
  theme_bw() + 
  labs(title = 'Simulated data with (green) and without (red) precipitation')
```

## First attempt at a state-approach

Let $B_t$ be the stock biomass at time $t$; The most simplistic Schaefer formulation states that, if cephalopod stocks followed the usual equilibrium assumptions, then

$$
B_{t+1} = r \cdot B_t \left(1 - \frac{B_t}{K} \right) - C_t
$$

We will take a first pass at inference on $B_t$ by treating it as a latent variable and using $C_t$ as the observation sequence. The link between $B_t$ and $C_t$ is given by

$$
\frac{C_t}{E_t} = q \cdot B_t
$$

which means the likelihood function for $B_t$ is derived from its distribution being:

$$
B_t \sim N(q \cdot \frac{C_t}{E_t}, \sigma_{B_t})
$$

for this to work, we need to estimate $q$, $K$, $r$, $B_0$ as well as every point for $B_t$. Fun times! At this time, we will not attempt to directly model parameter uncertainty nor the process error, because life is already too hard as it is.


```{r}
#| eval: false
dat = list()

# DO NOT USE DATA FRAMES!
# P_{t-1} = lagP

dat$Ct = as.vector(df_effort$catch_otb)  # catches
# dat$x = as.vector(rep(precip[1:29], each = 12)) # rainfall
dat$Et = as.vector(df_effort$effort_otb) # effort

# initialize parameter list with initial estimates
par = list()
par$Bt = numeric(length(dat$Ct)) # init empty vector
par$q = 1
par$r = 1
par$K = 1
par$B0 = 4*mean(dat$Ct)

par$logsdBt = 1
par$logsdCt = 1
# First pass: Linear model, lol

# initialize joint negative loglikelihood function
jnll = function(par){
  getAll(par, dat) # invoke all the parameters and data
  
  # gather and cleanup pars
  Ct = OBS(Ct)
  sdBt = exp(logsdBt)
  sdCt = exp(logsdCt)
  
  # assemble model    
  jnll = 0 # init jnll
  
  ## From the observation equation
  catch_predictions = c()
  for(i in 1:length(Ct)){
   Ct_hat = q*Bt[i]*Et[i]
   jnll = jnll -dnorm(Ct[i], Ct_hat, sdCt, log = TRUE)
   catch_predictions[i] = Ct_hat
 }
  
  ## From the process equation
  predictions = c(B0)
  
  for(i in 2:length(Ct)){
    predBt = r * Bt[i-1]*(1-(Bt[i-1]/K))-Ct[i-1]
    jnll = jnll - dnorm(Bt[i], predBt, sdBt, log=TRUE)
    predictions[i] = predBt
  }
  REPORT(predictions)
  REPORT(catch_predictions)
  jnll
}

# quick test: do we get a number? This number should be a likelihood.
jnll(par)

obj4 = MakeADFun(jnll, par)
fit4 = nlminb(obj4$par, obj4$fn, obj4$gr)

sdr4 = sdreport(obj4)
pl4 = as.list(sdr4,"Est")
plsd4 = as.list(sdr4,"Std")

sdr4

```

### Plotting Biomass estimates

```{r}
ggplot() +
  geom_line(aes(x = 1:348,
                y = obj4$report()$catch_predictions),
            color = 'red') +
  geom_line(aes(x = 1:348,
                y = df_effort$catch_otb)) +
  theme_bw()



temp = data.frame(x = obj4$report()$predictions) %>% 
  mutate(y = sdr4$par.fixed[['r']]*x *
           (1-(x/sdr4$par.fixed[['K']])))

ggplot() +
  geom_point(aes(y  = temp$y,
                x = temp$x),
            color = 'red') +

  theme_bw()
```




```{r}
df_effort %>% 
  ggplot() + 
  geom_point(aes(y = catch_otb/effort_otb,
                x = effort_otb)) + 
  theme_bw() + 
  labs(title = 'Catch ~ Effort')
```
```{r}
modelo = lm(df_effort$catch_otb/df_effort$effort_otb ~ df_effort$effort_otb)

a = modelo$coefficients[["df_effort$effort_otb"]]
b = modelo$coefficients[['(Intercept)']]

df_effort %>% 
ggplot() + 
  geom_point(aes(x = effort_otb,
                 y = catch_otb/effort_otb)) + 
  geom_abline(slope = a, intercept = b, color = 'red') + 
  theme_bw()

```

```{r}
novo = df_effort %>% 
  mutate(
  cpue_hat = predict(modelo, newdata = df_effort),
                  Y = cpue_hat * df_effort$effort_otb)

novo %>% 
  ggplot() +
  geom_point(aes(x = effort_otb,
                 y = catch_otb), col = 'red') + 
  geom_point(aes(x = effort_otb,
                 y = Y))

novo
```

#
